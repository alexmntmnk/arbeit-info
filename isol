Уровни изоляции транзакций

феномен грязного чтения – когда исполняющаяся транзакция видит все незафиксированные изменения другой транзакции
феномен неповторяющегося чтения – когда исполняющаяся транзакция видит все обновленные и удаленные строки (UPDATE, DELETE) другой транзакции (т.е. закоммиченные изменения)
феномен чтения фантомов – когда исполняющаяся транзакция видит все добавленные записи (INSERT) другой транзакции (т.е. закоммиченные изменения)

Read uncommitted чтение незавершенных транзакций
Уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций.
феномен грязного чтения
феномен неповторяющегося чтения
феномен чтения фантомов

Read committed чтение завершенных транзакций
феномен неповторяющегося чтения
феномен чтения фантомов


Repeatable read повторяемое чтение
феномен чтения фантомов

Serializable последовательное чтение
Нет ни одного феномена






Стоит отметить, что самую высокую скорость выполнения и самую низкую согласованность имеет уровень read uncommitted. Самую низкую скорость выполнения и самую высокую согласованность — serializable.


разные СУБД по-разному воспринимают уровни изолированности. Могут иметь разнообразные нюансы в обеспечении изоляции, иметь дополнительные уровни или не иметь общеизвестных. Например PostgreSQL не поддерживает уровень изоляции read uncommitted, и использует вместо него уровень read committed.
Примеры будем выполнять на 2 параллельно исполняющихся транзакциях. Условно транзакцию в левом окне будем называть транзакция 1 (Т1), в правом окне — транзакция 2 (Т2).


Read uncommitted чтение незавершенных транзакций

Уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций. Название уровня говорит само за себя — каждая транзакция видит незафиксированные изменения другой транзакции (феномен грязного чтения). Посмотрим какое влияние оказывают друг на друга такие транзакции.

Начинаем 2 параллельные транзакции Т1 и Т2
Теперь выполняем операции INSERT, DELETE, UPDATE в Т1, и посмотрим, что теперь видит другая транзакция.
Т2 видит данные другой транзакции (Т1), которые еще не были зафиксированы.
При откате изменений Т1, данные полученные Т2 окажутся ошибочными.
На данном уровне нельзя использовать данные, на основе которых делаются важные для приложения выводы и критические решения т.к выводы эти могут быть далеки от реальности.
Данный уровень можно использовать, например, для примерных расчетов чего-либо. Результат COUNT(*) или MAX(*) можно использовать в каких-нибудь нестрогих отчетах.
Другой пример это режим отладки. Когда во время транзакции, вы хотите видеть, что происходит с базой.

Read committed чтение завершенных транзакций

Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других транзакций. Таким образом, данный уровень обеспечивает защиту от грязного чтения.

Начинаем 2 параллельные транзакции Т1 и Т2
выполняем операции INSERT, DELETE, UPDATE в Т1, и посмотрим, что теперь видит другая транзакция.
И увидим, что феномен грязного чтения в Т2 отсутствует.
Зафиксируем изменения Т1 и проверим, что теперь видит Т2.
Теперь Т2 в исполняющейся транзакции видит все, что сделала Т1. 
Это так называемые феномен неповторяющегося чтения, когда мы видим обновленные и удаленные строки (UPDATE, DELETE), 
и феномен чтения фантомов, когда мы видим добавленные записи (INSERT).

Repeatable read повторяемое чтение
это уровень изоляции, при котором транзакция может повторять чтение данных многократно и каждый раз получать один и тот же результат, независимо от изменений (UPDATE, DELETE), производимых другими транзакциями.
Уровень, позволяющий предотвратить феномен неповторяющегося чтения. Т.е. мы не видим в исполняющейся транзакции измененные и удаленные записи другой транзакцией. Но все еще видим вставленные записи из другой транзакции. 
Чтение фантомов никуда не уходит.

Начинаем 2 параллельные транзакции Т1 и Т2
выполняем операции INSERT, DELETE, UPDATE в Т1, и посмотрим, что теперь видит другая транзакция.
И увидим, что феномен грязного чтения в Т2 отсутствует.
После, в Т2 пытаемся обновить ту же самую строку, которую обновили в Т1.
И получаем lock: T2 будет ждать, пока T1 не зафиксирует изменения или не откатится.
---------------------
Небольшой абстрактный пример — сервис генерации подарочных сертификатов (кодов) и их использования. Например, злоумышленник сгенерировал себе код сертификата и пытается его активировать, пытаясь послать несколько запросов подряд на активацию купона. В таком случае у нас запустится несколько параллельно исполняемых транзакций, работающих с одним и тем же купоном. И в некоторых ситуациях может возникнуть двойная или даже тройная активация купона (пользователь получит 2x/3x бонусов). При repeatable read в данном случае возникнет lock и активация пройдет единожды, а в предыдущих 2 уровнях возможна многократная активация. Подобную проблему можно также решить с помощью запроса SELECT FOR UPDATE, который также заблокирует обновляемую запись (купон).
---------------------

Зафиксируем изменения Т1 и проверим, что теперь видит Т2.
феномен неповторяющегося чтения пропал

Serializable последовательное чтение

Уровень, при котором транзакции ведут себя как будто ничего более не существует, никакого влияния друг на друга нет, т.е. они выполняются как буд-то строго последовательно. В классическом представлении этот уровень избавляет от эффекта чтения фантомов.

Начинаем 2 параллельные транзакции Т1 и Т2
выполняем операции INSERT, DELETE, UPDATE в Т1, и посмотрим, что теперь видит другая транзакция.
И увидим, что феномен грязного чтения в Т2 отсутствует.
После, в Т2 пытаемся обновить ту же самую строку, которую обновили в Т1.
И получаем lock: T2 будет ждать, пока T1 не зафиксирует изменения или не откатится.
И INSERT и DELETE ведет нас к lock'у в Т1.
Пока Т2 не завершит свою работу, мы не сможем работать с данными, которые она прочитала. Мы получаем максимальную согласованность данных, никакие лишние данные не зафиксируются. Цена за это медленная скорость транзакций из-за частых lock'ов поэтому при плохой архитектуре приложения это может сыграть с Вами злую шутку.


В большинстве приложений уровень изолированности редко меняется и используется значение по умолчанию (например, в MySQL это repeatable read, в PostgreSQL — read committed).
